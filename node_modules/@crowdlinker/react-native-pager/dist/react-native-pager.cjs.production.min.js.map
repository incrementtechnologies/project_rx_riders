{"version":3,"file":"react-native-pager.cjs.production.min.js","sources":["../src/pager.tsx","../src/util.ts","../src/pagination.tsx"],"sourcesContent":["import React, {\n  useState,\n  Children,\n  createContext,\n  useContext,\n  useEffect,\n} from 'react';\nimport { StyleSheet, LayoutChangeEvent, ViewStyle } from 'react-native';\nimport Animated from 'react-native-reanimated';\nimport {\n  PanGestureHandler,\n  State,\n  PanGestureHandlerProperties,\n} from 'react-native-gesture-handler';\n\nexport type SpringConfig = {\n  damping: Animated.Adaptable<number>;\n  mass: Animated.Adaptable<number>;\n  stiffness: Animated.Adaptable<number>;\n  overshootClamping: Animated.Adaptable<number> | boolean;\n  restSpeedThreshold: Animated.Adaptable<number>;\n  restDisplacementThreshold: Animated.Adaptable<number>;\n  toValue: Animated.Adaptable<number>;\n};\n\n// copied from react-native-reanimated for now, can't get the export\nexport enum Extrapolate {\n  EXTEND = 'extend',\n  CLAMP = 'clamp',\n  IDENTITY = 'identity',\n}\n\ninterface InterpolationConfig {\n  inputRange: ReadonlyArray<Animated.Adaptable<number>>;\n  outputRange: ReadonlyArray<Animated.Adaptable<number>>;\n  extrapolate?: Extrapolate;\n  extrapolateLeft?: Extrapolate;\n  extrapolateRight?: Extrapolate;\n}\n\ntype iInterpolationFn = (\n  offset: Animated.Node<number>\n) => Animated.Node<number>;\n\ninterface iInterpolationConfig extends InterpolationConfig {\n  unit?: string;\n}\n\ntype iTransformProp = {\n  [transformProp: string]: iInterpolationConfig | iInterpolationFn;\n};\n\nexport interface iPageInterpolation {\n  [animatedProp: string]:\n    | iTransformProp[]\n    | iInterpolationConfig\n    | iInterpolationFn;\n}\n\nconst VERTICAL = 1;\nconst HORIZONTAL = 2;\nconst UNSET = -1;\nconst TRUE = 1;\nconst FALSE = 0;\n\nconst {\n  event,\n  block,\n  Value,\n  divide,\n  cond,\n  eq,\n  add,\n  stopClock,\n  Clock,\n  set,\n  clockRunning,\n  multiply,\n  sub,\n  call,\n  max,\n  min,\n  greaterThan,\n  abs,\n  ceil,\n  interpolate,\n  concat,\n  neq,\n  and,\n  startClock,\n  spring,\n  // @ts-ignore\n  debug,\n} = Animated;\n\nexport interface iPager {\n  activeIndex?: number;\n  onChange?: (nextIndex: number) => void;\n  initialIndex?: number;\n  children: React.ReactNode[];\n  springConfig?: Partial<SpringConfig>;\n  pageInterpolation?: iPageInterpolation;\n  panProps?: Partial<PanGestureHandlerProperties>;\n  pageSize?: number;\n  threshold?: number;\n  minIndex?: number;\n  maxIndex?: number;\n  adjacentChildOffset?: number;\n  style?: ViewStyle;\n  containerStyle?: ViewStyle;\n  animatedValue?: Animated.Value<number>;\n  animatedIndex?: Animated.Value<number>;\n  type?: 'horizontal' | 'vertical';\n  clamp?: {\n    prev?: number;\n    next?: number;\n  };\n  clampDrag?: {\n    prev?: number;\n    next?: number;\n  };\n}\nconst REALLY_BIG_NUMBER = 1000000000;\n\n// at its core, this component converts an activeIndex integer value to an Animated.Value\n// this animated value represents all intermediate values of a pager, e.g when a user is dragging, the index\n// value might be anything between 1 -> 2 as they are moving. when a gesture is completed, it figures out\n// the next activeIndex, snaps to it and passes it back. it also handles snapping to different indices when the activeIndex\n// prop changes.\n\n// all styles and positioning of child screens can be computed from this one value, based on a childs index and\n// any style config props passed to the Pager.\n\n// pretty much all other props passed to the Pager are configurations for different behaviours of what is described above\n\nfunction Pager({\n  activeIndex: parentActiveIndex,\n  onChange: parentOnChange,\n  initialIndex = 0,\n  children,\n  springConfig,\n  panProps = {},\n  pageSize = 1,\n  threshold = 0.1,\n  minIndex = 0,\n  maxIndex: parentMax,\n  adjacentChildOffset = 10,\n  style,\n  containerStyle,\n  type = 'horizontal',\n  pageInterpolation,\n  clamp = {},\n  clampDrag = {},\n  animatedValue,\n}: iPager) {\n  const context = useContext(PagerContext);\n\n  const isControlled = parentActiveIndex !== undefined;\n\n  const [_activeIndex, _onChange] = useState(initialIndex);\n\n  const activeIndex = isControlled\n    ? (parentActiveIndex as number)\n    : context\n    ? (context[0] as number)\n    : (_activeIndex as number);\n\n  const numberOfScreens = Children.count(children);\n\n  const maxIndex =\n    parentMax === undefined\n      ? Math.ceil((numberOfScreens - 1) / pageSize)\n      : parentMax;\n\n  const onChange = isControlled\n    ? (parentOnChange as any)\n    : context\n    ? (context[1] as any)\n    : (_onChange as any);\n\n  const dragX = memoize(new Value(0));\n  const dragY = memoize(new Value(0));\n  const gestureState = memoize(new Value(0));\n\n  const handleGesture = memoize(\n    event(\n      [\n        {\n          nativeEvent: {\n            translationX: dragX,\n            translationY: dragY,\n          },\n        },\n      ],\n      { useNativeDriver: true }\n    )\n  );\n\n  const handleStateChange = memoize(\n    event(\n      [\n        {\n          nativeEvent: {\n            state: gestureState,\n          },\n        },\n      ],\n      {\n        useNativeDriver: true,\n      }\n    )\n  );\n\n  let initialWidth = UNSET;\n  if (style && style.width) {\n    if (typeof style.width === 'number') {\n      initialWidth = style.width;\n    }\n  }\n\n  let initialHeight = UNSET;\n  if (style && style.height) {\n    if (typeof style.height === 'number') {\n      initialHeight = style.height;\n    }\n  }\n\n  const [width, setWidth] = useState(initialWidth);\n  const [height, setHeight] = useState(initialHeight);\n\n  // assign references based on vertical / horizontal configurations\n  const dimension = memoize(new Value(0));\n  const targetDimension = type === 'vertical' ? 'height' : 'width';\n  const targetTransform = type === 'vertical' ? 'translateY' : 'translateX';\n  const delta = type === 'vertical' ? dragY : dragX;\n\n  const layoutDimension = type === 'vertical' ? height : width;\n\n  // `totalDimension` on the container view is required for android layouts to work properly\n  // otherwise translations move the panHandler off of the screen\n  // set the total width of the container view to the sum width of all the screens\n  const totalDimension = multiply(dimension, numberOfScreens);\n\n  function handleLayout({ nativeEvent: { layout } }: LayoutChangeEvent) {\n    layout.width !== width && setWidth(layout.width);\n    layout.height !== height && setHeight(layout.height);\n  }\n\n  const TYPE = type === 'vertical' ? VERTICAL : HORIZONTAL;\n\n  // props that might change over time should be reactive:\n  const animatedThreshold = useAnimatedValue(threshold);\n  const clampDragPrev = useAnimatedValue(clampDrag.prev, REALLY_BIG_NUMBER);\n  const clampDragNext = useAnimatedValue(clampDrag.next, REALLY_BIG_NUMBER);\n  const animatedMaxIndex = useAnimatedValue(maxIndex);\n  const animatedMinIndex = useAnimatedValue(minIndex);\n\n  // set the initial position - priority to direct prop over context, and context over uncontrolled\n  const _position = memoize(new Value(activeIndex));\n  const position = animatedValue\n    ? animatedValue\n    : context\n    ? context[2]\n    : _position;\n\n  // pan event values to track\n  const dragStart = memoize(new Value(0));\n  const swiping = memoize(new Value(FALSE));\n  const nextIndex = memoize(new Value(activeIndex));\n  const animatedActiveIndex = memoize(new Value(activeIndex));\n  const change = memoize(sub(animatedActiveIndex, position));\n  const absChange = memoize(abs(change));\n  const shouldTransition = memoize(greaterThan(absChange, animatedThreshold));\n  const indexChange = memoize(new Value(0));\n\n  // clamp drag values between the configured clamp props\n  // e.g prev => 0.5, next => 0.5 means change can only be between [-0.5, 0.5]\n  // minMax order is reversed because next is negative in translation values\n  const clampedDelta = memoize(\n    min(\n      max(divide(delta, dimension), multiply(clampDragNext, -1)),\n      clampDragPrev\n    )\n  );\n\n  const clock = memoize(new Clock());\n\n  // snap focus to activeIndex when it updates\n  useEffect(() => {\n    if (activeIndex >= minIndex && activeIndex <= maxIndex) {\n      nextIndex.setValue(activeIndex);\n    }\n  }, [activeIndex, minIndex, maxIndex]);\n\n  // animatedIndex represents pager position with an animated value\n  // this value is used to compute the transformations of the container screen\n  // its also used to compute the offsets of child screens, and any other consumers\n  const animatedIndex = memoize(\n    block([\n      cond(\n        eq(gestureState, State.ACTIVE),\n        [\n          cond(clockRunning(clock), stopClock(clock)),\n          // captures the initial drag value on first drag event\n          cond(swiping, 0, [set(dragStart, position), set(swiping, TRUE)]),\n\n          set(position, sub(dragStart, clampedDelta)),\n        ],\n        [\n          // on release -- figure out if the index needs to change, and what index it should change to\n          cond(swiping, [\n            set(swiping, FALSE),\n            cond(shouldTransition, [\n              // rounds index change if pan gesture greater than just one screen\n              set(indexChange, ceil(absChange)),\n              // nextIndex set to the next snap point\n              set(\n                nextIndex,\n                cond(\n                  greaterThan(change, 0),\n                  min(\n                    max(\n                      sub(animatedActiveIndex, indexChange),\n                      animatedMinIndex\n                    ),\n                    animatedMaxIndex\n                  ),\n                  min(\n                    max(\n                      add(animatedActiveIndex, indexChange),\n                      animatedMinIndex\n                    ),\n                    animatedMaxIndex\n                  )\n                )\n              ),\n              // update w/ value that will be snapped to\n              call([nextIndex], ([nextIndex]) => onChange(nextIndex)),\n            ]),\n          ]),\n\n          // set animatedActiveIndex for next swipe event\n          set(animatedActiveIndex, nextIndex),\n          set(position, runSpring(clock, position, nextIndex, springConfig)),\n        ]\n      ),\n      position,\n    ])\n  );\n\n  const clampPrevValue = useAnimatedValue(clamp.prev, numberOfScreens);\n  const clampNextValue = useAnimatedValue(clamp.next, numberOfScreens);\n\n  // stop child screens from translating beyond the bounds set by clamp props:\n  const minimum = memoize(\n    multiply(sub(animatedIndex, clampPrevValue), dimension)\n  );\n\n  const maximum = memoize(\n    multiply(add(animatedIndex, clampNextValue), dimension)\n  );\n\n  const animatedPageSize = useAnimatedValue(pageSize);\n\n  // container offset -- this is the window of focus for active screens\n  // it shifts around based on the animatedIndex value\n  const containerTranslation = memoize(\n    multiply(animatedIndex, dimension, animatedPageSize, -1)\n  );\n\n  // slice the children that are rendered by the <Pager />\n  // this enables very large child lists to render efficiently\n  // the downside is that children are unmounted after they pass this threshold\n  // it's an optional prop, however a default value of ~20 is set here to prevent\n  // possible performance bottlenecks to those not aware of the prop or what it does\n\n  // this will slice adjacentChildOffset number of children previous and after\n  // the current active child index into a smaller child array\n  const adjacentChildren =\n    adjacentChildOffset !== undefined\n      ? children.slice(\n          Math.max(activeIndex - adjacentChildOffset, 0),\n          Math.min(activeIndex + adjacentChildOffset + 1, numberOfScreens)\n        )\n      : children;\n\n  // grabbing the height property from the style prop if there is no container style, this reduces\n  // the chances of messing up the layout with containerStyle configurations\n  // can be overridden by the prop itself, but its likely that this is what is intended most of the time\n  // also has the benefit of covering 100% width of container, meaning better pan coverage on android\n  const defaultContainerStyle =\n    style && style.height ? { height: style.height } : undefined;\n\n  function renderChildren() {\n    // waiting for initial layout - except when testing\n    if (width === UNSET) {\n      return null;\n    }\n\n    return adjacentChildren.map((child: any, i) => {\n      // use map instead of React.Children because we want to track\n      // the keys of these children by there index\n      // React.Children shifts these key values intelligently, but it\n      // causes issues with the memoized values in <Page /> components\n      let index = i;\n\n      if (adjacentChildOffset !== undefined) {\n        index =\n          activeIndex <= adjacentChildOffset\n            ? i\n            : activeIndex - adjacentChildOffset + i;\n      }\n\n      return (\n        <IndexProvider index={index} key={index}>\n          <FocusProvider focused={index === activeIndex}>\n            <Page\n              index={index}\n              animatedIndex={animatedIndex}\n              minimum={minimum}\n              maximum={maximum}\n              dimension={dimension}\n              targetTransform={targetTransform}\n              targetDimension={targetDimension}\n              pageInterpolation={pageInterpolation}\n            >\n              {child}\n            </Page>\n          </FocusProvider>\n        </IndexProvider>\n      );\n    });\n  }\n\n  // extra Animated.Views below may seem redundant but they preserve applied styles e.g padding and margin\n  // of the page views\n  return (\n    <Animated.View\n      style={containerStyle || defaultContainerStyle || { flex: 1 }}\n    >\n      <Animated.Code\n        key={layoutDimension}\n        exec={cond(\n          // dimension already set to last layout\n          and(eq(dimension, width), eq(dimension, height)),\n          [],\n          [\n            cond(\n              eq(TYPE, VERTICAL),\n              set(dimension, height),\n              set(dimension, width)\n            ),\n          ]\n        )}\n      />\n\n      <PanGestureHandler\n        {...panProps}\n        onGestureEvent={handleGesture}\n        onHandlerStateChange={handleStateChange}\n      >\n        <Animated.View style={{ flex: 1 }}>\n          <Animated.View style={style || { flex: 1 }}>\n            <Animated.View style={{ flex: 1 }} onLayout={handleLayout}>\n              <Animated.View\n                style={{\n                  flex: 1,\n                  [targetDimension]: totalDimension,\n                  transform: [{ [targetTransform]: containerTranslation }],\n                }}\n              >\n                {renderChildren()}\n              </Animated.View>\n            </Animated.View>\n          </Animated.View>\n        </Animated.View>\n      </PanGestureHandler>\n    </Animated.View>\n  );\n}\n\ninterface iPage {\n  children: React.ReactNode;\n  index: number;\n  minimum: Animated.Node<number>;\n  maximum: Animated.Node<number>;\n  dimension: Animated.Node<number>;\n  targetTransform: 'translateX' | 'translateY';\n  targetDimension: 'width' | 'height';\n  pageInterpolation: iPageInterpolation | undefined;\n  animatedIndex: Animated.Value<number>;\n}\n\nfunction Page({\n  children,\n  index,\n  minimum,\n  maximum,\n  dimension,\n  targetTransform,\n  targetDimension,\n  pageInterpolation,\n  animatedIndex,\n}: iPage) {\n  // compute the absolute position of the page based on index and dimension\n  // this means that it's not relative to any other child, which is good because\n  // it doesn't rely on a mechanism like flex, which requires all children to be present\n  // to properly position pages\n  const position = memoize(multiply(index, dimension));\n\n  // min-max the position based on clamp values\n  // this means the <Page /> will have a container that is always positioned\n  // in the same place, but the inner view can be translated within these bounds\n  const translation = memoize(min(max(position, minimum), maximum));\n\n  const defaultStyle = memoize({\n    // map to height / width value depending on vertical / horizontal configuration\n    // this is crucial to getting child views to properly lay out\n    [targetDimension]: dimension,\n    // min-max the position based on clamp values\n    // this means the <Page /> will have a container that is always positioned\n    // in the same place, but the inner view can be translated within these bounds\n    transform: [\n      {\n        [targetTransform]: translation,\n      },\n    ],\n  });\n\n  // compute the relative offset value to the current animated index so\n  // that <Page /> can use interpolation values that are in sync with drag gestures\n  const offset = memoize(sub(index, animatedIndex));\n\n  // apply interpolation configs to <Page />\n  const interpolatedStyles = memoize(\n    interpolateWithConfig(offset, pageInterpolation)\n  );\n\n  // take out zIndex here as it needs to be applied to siblings\n  let { zIndex, ...otherStyles } = interpolatedStyles;\n\n  // zIndex is not a requirement of interpolation\n  // it will be clear when someone needs it as views will overlap with some configurations\n  if (!zIndex) {\n    zIndex = 0;\n  }\n\n  return (\n    <Animated.View\n      style={{\n        ...StyleSheet.absoluteFillObject,\n        ...defaultStyle,\n        zIndex,\n      }}\n    >\n      <Animated.View style={[StyleSheet.absoluteFillObject, otherStyles]}>\n        {children}\n      </Animated.View>\n    </Animated.View>\n  );\n}\n\n// utility to update animated values without changing their reference\n// this is key for using memoized Animated.Values and prevents costly rerenders\nfunction useAnimatedValue(\n  value?: number,\n  defaultValue = 0\n): Animated.Value<number> {\n  const initialValue = value !== undefined ? value : defaultValue;\n  const animatedValue = memoize(new Value(initialValue));\n\n  useEffect(() => {\n    if (value !== undefined) {\n      animatedValue.setValue(value);\n    }\n  }, [value]);\n\n  return animatedValue;\n}\n\ntype iPagerContext = [\n  number,\n  (nextIndex: number) => void,\n  Animated.Value<number>\n];\n\nconst PagerContext = createContext<undefined | iPagerContext>(undefined);\n\ninterface iPagerProvider {\n  children: React.ReactNode;\n  initialIndex?: number;\n  activeIndex?: number;\n  onChange?: (nextIndex: number) => void;\n}\n\nfunction PagerProvider({\n  children,\n  initialIndex = 0,\n  activeIndex: parentActiveIndex,\n  onChange: parentOnChange = () =>\n    console.warn(\n      '<PagerProvider /> should have an onChange() prop if it is controlled'\n    ),\n}: iPagerProvider) {\n  const [_activeIndex, _setActiveIndex] = useState(initialIndex);\n\n  const isControlled = parentActiveIndex !== undefined;\n\n  const activeIndex = isControlled ? parentActiveIndex : _activeIndex;\n  const onChange = isControlled ? parentOnChange : _setActiveIndex;\n\n  const animatedIndex = memoize(new Value(activeIndex));\n\n  return (\n    <PagerContext.Provider\n      value={[activeIndex, onChange, animatedIndex] as iPagerContext}\n    >\n      {typeof children === 'function'\n        ? children({ activeIndex, onChange, animatedIndex })\n        : children}\n    </PagerContext.Provider>\n  );\n}\n\nfunction usePager(): iPagerContext {\n  const context = useContext(PagerContext);\n\n  if (context === undefined) {\n    throw new Error(`usePager() must be used within a <PagerProvider />`);\n  }\n\n  return context;\n}\n\n// provide hook for child screens to access pager focus:\nconst FocusContext = React.createContext(false);\n\ninterface iFocusProvider {\n  children: React.ReactNode;\n  focused: boolean;\n}\n\nfunction FocusProvider({ focused, children }: iFocusProvider) {\n  return (\n    <FocusContext.Provider value={focused}>{children}</FocusContext.Provider>\n  );\n}\n\nfunction useFocus() {\n  const focused = useContext(FocusContext);\n\n  return focused;\n}\n\nconst IndexContext = React.createContext<undefined | number>(undefined);\n\ninterface iIndexProvider {\n  children: React.ReactNode;\n  index: number;\n}\n\nfunction IndexProvider({ children, index }: iIndexProvider) {\n  return (\n    <IndexContext.Provider value={index}>{children}</IndexContext.Provider>\n  );\n}\n\nfunction useIndex() {\n  const index = useContext(IndexContext);\n\n  if (index === undefined) {\n    throw new Error(`useIndex() must be used within an <IndexProvider />`);\n  }\n\n  return index;\n}\n\nfunction useOnFocus(fn: Function) {\n  const focused = useFocus();\n\n  useEffect(() => {\n    if (focused) {\n      fn();\n    }\n  }, [focused]);\n}\n\nfunction useAnimatedIndex() {\n  const pager = usePager();\n  return pager[2];\n}\n\nfunction useOffset(index: number) {\n  const animatedIndex = useAnimatedIndex();\n  const offset = memoize(sub(index, animatedIndex));\n\n  return offset;\n}\n\nfunction useInterpolation(\n  pageInterpolation: iPageInterpolation,\n  index?: number\n) {\n  const _index = index !== undefined ? index : useIndex();\n  const offset = useOffset(_index);\n  const styles = memoize(interpolateWithConfig(offset, pageInterpolation));\n  return styles;\n}\n\nfunction interpolateWithConfig(\n  offset: Animated.Node<number>,\n  pageInterpolation?: iPageInterpolation\n): ViewStyle {\n  if (!pageInterpolation) {\n    return {};\n  }\n\n  return Object.keys(pageInterpolation).reduce((styles: any, key: any) => {\n    const currentStyle = pageInterpolation[key];\n\n    if (Array.isArray(currentStyle)) {\n      const _style = currentStyle.map((interpolationConfig: any) =>\n        interpolateWithConfig(offset, interpolationConfig)\n      );\n\n      styles[key] = _style;\n      return styles;\n    }\n\n    if (typeof currentStyle === 'object') {\n      let _style;\n      const { unit, ...rest } = currentStyle;\n      if (currentStyle.unit) {\n        _style = concat(interpolate(offset, rest), currentStyle.unit);\n      } else {\n        _style = interpolate(offset, currentStyle);\n      }\n\n      styles[key] = _style;\n      return styles;\n    }\n\n    if (typeof currentStyle === 'function') {\n      const _style = currentStyle(offset);\n      styles[key] = _style;\n      return styles;\n    }\n\n    return styles;\n  }, {});\n}\n\nfunction memoize(value: any): any {\n  const ref = React.useRef(value);\n  return ref.current;\n}\n\nconst DEFAULT_SPRING_CONFIG = {\n  stiffness: 1000,\n  damping: 500,\n  mass: 3,\n  overshootClamping: false,\n  restDisplacementThreshold: 0.01,\n  restSpeedThreshold: 0.01,\n};\n\nfunction runSpring(\n  clock: Animated.Clock,\n  position: Animated.Value<number>,\n  toValue: Animated.Node<number>,\n  springConfig?: Partial<SpringConfig>\n) {\n  const state = {\n    finished: new Value(0),\n    velocity: new Value(0),\n    position: position,\n    time: new Value(0),\n  };\n\n  const config = {\n    ...DEFAULT_SPRING_CONFIG,\n    ...springConfig,\n    toValue: new Value(0),\n  };\n\n  return block([\n    cond(\n      clockRunning(clock),\n      [\n        cond(neq(config.toValue, toValue), [\n          set(state.finished, 0),\n          set(config.toValue, toValue),\n        ]),\n      ],\n      [\n        set(state.finished, 0),\n        set(state.time, 0),\n        set(state.velocity, 0),\n        set(config.toValue, toValue),\n        startClock(clock),\n      ]\n    ),\n    spring(clock, state, config),\n    cond(state.finished, [stopClock(clock), set(state.position, position)]),\n    state.position,\n  ]);\n}\n\nexport {\n  Pager,\n  PagerProvider,\n  PagerContext,\n  usePager,\n  useFocus,\n  useOffset,\n  useOnFocus,\n  useIndex,\n  useAnimatedIndex,\n  useInterpolation,\n  IndexProvider,\n  FocusProvider,\n};\n","import { useRef } from 'react';\nimport { ViewStyle } from 'react-native';\nimport Animated from 'react-native-reanimated';\nimport { iPageInterpolation, SpringConfig } from './pager';\n\nconst {\n  interpolate,\n  concat,\n  Value,\n  clockRunning,\n  cond,\n  neq,\n  set,\n  startClock,\n  spring,\n  stopClock,\n  block,\n} = Animated;\n\nfunction interpolateWithConfig(\n  offset: Animated.Node<number>,\n  pageInterpolation?: iPageInterpolation\n): ViewStyle {\n  if (!pageInterpolation) {\n    return {};\n  }\n\n  return Object.keys(pageInterpolation).reduce((styles: any, key: any) => {\n    const currentStyle = pageInterpolation[key];\n\n    if (Array.isArray(currentStyle)) {\n      const _style = currentStyle.map((interpolationConfig: any) =>\n        interpolateWithConfig(offset, interpolationConfig)\n      );\n\n      styles[key] = _style;\n      return styles;\n    }\n\n    if (typeof currentStyle === 'object') {\n      let _style;\n      const { unit, ...rest } = currentStyle;\n      if (currentStyle.unit) {\n        _style = concat(interpolate(offset, rest), currentStyle.unit);\n      } else {\n        _style = interpolate(offset, currentStyle);\n      }\n\n      styles[key] = _style;\n      return styles;\n    }\n\n    if (typeof currentStyle === 'function') {\n      const _style = currentStyle(offset);\n      styles[key] = _style;\n      return styles;\n    }\n\n    return styles;\n  }, {});\n}\n\nfunction memoize(value: any): any {\n  const ref = useRef(value);\n  return ref.current;\n}\n\nconst DEFAULT_SPRING_CONFIG = {\n  stiffness: 1000,\n  damping: 500,\n  mass: 3,\n  overshootClamping: false,\n  restDisplacementThreshold: 0.01,\n  restSpeedThreshold: 0.01,\n};\n\nfunction runSpring(\n  clock: Animated.Clock,\n  position: Animated.Value<number>,\n  toValue: Animated.Node<number>,\n  springConfig?: Partial<SpringConfig>\n) {\n  const state = {\n    finished: new Value(0),\n    velocity: new Value(0),\n    position: position,\n    time: new Value(0),\n  };\n\n  const config = {\n    ...DEFAULT_SPRING_CONFIG,\n    ...springConfig,\n    toValue: new Value(0),\n  };\n\n  return block([\n    cond(\n      clockRunning(clock),\n      [\n        cond(neq(config.toValue, toValue), [\n          set(state.finished, 0),\n          set(config.toValue, toValue),\n        ]),\n      ],\n      [\n        set(state.finished, 0),\n        set(state.time, 0),\n        set(state.velocity, 0),\n        set(config.toValue, toValue),\n        startClock(clock),\n      ]\n    ),\n    spring(clock, state, config),\n    cond(state.finished, [stopClock(clock), set(state.position, position)]),\n    state.position,\n  ]);\n}\n\nexport { interpolateWithConfig, memoize, runSpring };\n","import React, { Children } from 'react';\nimport Animated from 'react-native-reanimated';\nimport { ViewStyle, LayoutChangeEvent } from 'react-native';\nimport { iPageInterpolation, useOffset, useAnimatedIndex } from './pager';\nimport { memoize, interpolateWithConfig } from './util';\n\nconst { Value, divide, multiply, add } = Animated;\n\ninterface iPagination {\n  children: React.ReactNode;\n  pageInterpolation: iPageInterpolation;\n  style?: ViewStyle;\n}\n\nconst DEFAULT_PAGINATION_STYLE: ViewStyle = {\n  height: 50,\n  width: '100%',\n  flexDirection: 'row',\n};\n\nfunction Pagination({ children, pageInterpolation, style }: iPagination) {\n  return (\n    <Animated.View\n      style={{\n        ...DEFAULT_PAGINATION_STYLE,\n        ...style,\n      }}\n    >\n      {Children.map(children, (child: any, index) => (\n        <PaginationItem\n          index={index}\n          pageInterpolation={pageInterpolation}\n          style={child.props.style}\n        >\n          {child}\n        </PaginationItem>\n      ))}\n    </Animated.View>\n  );\n}\n\ninterface iPaginationItem {\n  children: React.ReactNode;\n  pageInterpolation: iPageInterpolation;\n  index: number;\n  style?: ViewStyle;\n}\n\nfunction PaginationItem({\n  children,\n  pageInterpolation,\n  index,\n  style,\n}: iPaginationItem) {\n  const offset = useOffset(index);\n  const configStyles = memoize(\n    interpolateWithConfig(offset, pageInterpolation)\n  );\n\n  return (\n    <Animated.View style={[style || { flex: 1 }, configStyles]}>\n      {children}\n    </Animated.View>\n  );\n}\n\ninterface iSlider {\n  numberOfScreens: number;\n  style: ViewStyle;\n}\n\nconst DEFAULT_SLIDER_STYLE = {\n  height: 2,\n  backgroundColor: 'aquamarine',\n};\n\nfunction Slider({ numberOfScreens, style }: iSlider) {\n  const animatedIndex = useAnimatedIndex();\n  const width = memoize(new Value(0));\n\n  function handleLayout({ nativeEvent: { layout } }: LayoutChangeEvent) {\n    width.setValue(layout.width as any);\n  }\n\n  const sliderWidth = divide(width, numberOfScreens);\n  const translation = memoize(multiply(animatedIndex, sliderWidth));\n\n  return (\n    <Animated.View onLayout={handleLayout}>\n      <Animated.View\n        style={{\n          width: sliderWidth,\n          transform: [{ translateX: translation }],\n          ...DEFAULT_SLIDER_STYLE,\n          ...style,\n        }}\n      />\n    </Animated.View>\n  );\n}\n\nfunction Progress({ numberOfScreens, style }: iSlider) {\n  const animatedIndex = useAnimatedIndex();\n\n  const width = memoize(new Value(0));\n\n  function handleLayout({ nativeEvent: { layout } }: LayoutChangeEvent) {\n    width.setValue(layout.width as any);\n  }\n\n  const sliderWidth = memoize(\n    divide(width, numberOfScreens, divide(1, add(animatedIndex, 1)))\n  );\n\n  return (\n    <Animated.View onLayout={handleLayout}>\n      <Animated.View\n        style={{\n          width: sliderWidth,\n          height: 2,\n          backgroundColor: 'rebeccapurple',\n          ...DEFAULT_SLIDER_STYLE,\n          ...style,\n        }}\n      />\n    </Animated.View>\n  );\n}\n\nexport { Pagination, Slider, Progress };\n"],"names":["Extrapolate","event","Animated","block","Value","divide","cond","eq","add","stopClock","Clock","set","clockRunning","multiply","sub","call","max","min","greaterThan","abs","ceil","interpolate","concat","neq","and","startClock","spring","Page","children","index","minimum","maximum","dimension","targetTransform","targetDimension","pageInterpolation","animatedIndex","position","memoize","translation","defaultStyle","transform","offset","interpolatedStyles","interpolateWithConfig","zIndex","otherStyles","React","View","style","StyleSheet","absoluteFillObject","useAnimatedValue","value","defaultValue","animatedValue","undefined","useEffect","setValue","PagerContext","createContext","usePager","context","useContext","Error","FocusContext","FocusProvider","Provider","focused","useFocus","IndexContext","IndexProvider","useIndex","useAnimatedIndex","useOffset","Object","keys","reduce","styles","key","currentStyle","Array","isArray","_style","map","interpolationConfig","rest","unit","useRef","current","DEFAULT_SPRING_CONFIG","stiffness","damping","mass","overshootClamping","restDisplacementThreshold","restSpeedThreshold","runSpring","clock","toValue","springConfig","state","finished","velocity","time","config","DEFAULT_PAGINATION_STYLE","height","width","flexDirection","PaginationItem","configStyles","flex","DEFAULT_SLIDER_STYLE","backgroundColor","parentActiveIndex","activeIndex","parentOnChange","onChange","initialIndex","panProps","pageSize","threshold","minIndex","parentMax","maxIndex","adjacentChildOffset","containerStyle","type","clamp","clampDrag","isControlled","useState","_onChange","numberOfScreens","Children","count","Math","dragX","dragY","gestureState","handleGesture","nativeEvent","translationX","translationY","useNativeDriver","handleStateChange","initialWidth","initialHeight","setWidth","setHeight","delta","layoutDimension","totalDimension","TYPE","animatedThreshold","clampDragPrev","prev","clampDragNext","next","animatedMaxIndex","animatedMinIndex","_position","dragStart","swiping","nextIndex","animatedActiveIndex","change","absChange","shouldTransition","indexChange","clampedDelta","State","ACTIVE","clampPrevValue","clampNextValue","animatedPageSize","containerTranslation","adjacentChildren","slice","Code","exec","PanGestureHandler","onGestureEvent","onHandlerStateChange","onLayout","layout","child","i","console","warn","props","sliderWidth","translateX","fn"],"mappings":"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"}